\subsection{Theoretical Background}

\subsubsection{Funarg Problem}
\emph{"Funarg Problem refers to the difficulty in implementing first-class functions (functions as first-class objects) in implementations with stack-based memory allocation."} says Wikipedia about \emph{Funarg Problem}.  To illustrate this, let us consider y from the previous example. As we mentioned already, would y nomally be out of scope at the moment the func1 is invoked (line 30). But since it is used in a first-class function, it becomes a free variable (contrary to bound varaibles) and can still be accessed even if the context of the variable is closed. In order to make this possible we introduce \emph{closures}, which binds the functional literals to their \emph{free variables}. One way of implementing this is descriped by the \emph{Lambda Lifting}. \newline

\subsection{New Elements in the Syntax Tree}
Before solving the Funarg problem, however, we first are going to illustrate how other elements of the compiler have been implemented. To start off with the new syntax which had to be introduced, we give here an overview:

\begin{lstlisting}
sealed trait TypeTree extends Tree
  //( type.. ) => returnType
  case class FuncType(arguments: List[TypeTree],
    returnType: TypeTree) extends TypeTree
  ...

sealed trait ExprTree extends Tree with Typed
  // ( arguments.. ) => { varDecl; statemenets; }
  case class FuncExpr(arguments: List[VarDecl],
    variables: List[VarDecl], statements: List[StatTree],
    returnExpr: Option[ExprTree])
    extends ExprTree with Symbolic[MethodSymbol]
  // func( arguments; )
  case class FuncCall(function: ExprTree,
    expressions: List[ExprTree]) extends ExprTree
  ...
\end{lstlisting}

Corresponding examples for each snytax shall here briefly presented:
\begin{enumerate}
\item \emph{FuncType} is used when a variable or a function to take or return a functional literal (line 10+12+24+25 of the example)
\item \emph{FuncExpr} is used when a functional literal is assigned to a variable or returned in a function (line 15 of the example)
\item \emph{FuncCall} is used when the functional literal is invoked (line 30+31+32 of the example)
\end{enumerate}

\subsection{Parser}
As it comes to the parser, there is one rather difficult case to mention, which includes to distinguish a functional literal from an expression starting with an opening bracket:
\begin{lstlisting}
f = (a: Int, b: Int) => {â€¦} // functional literal
f = (a + b) * c; // expression starting with "("
\end{lstlisting}
It makes it specially difficult since the toolc parser is some kind of a LL(1) parser. This means that the parser reads only one token after the other and does not remember passed token. In the previous example, the parser would first read the characters "f=(". At this point he knows, that an expression has to follow. But if the expression is just an identifier ("a" in the example), he does not know yet to distinguish the two cases. Only when reading one more token, he can identify a functional literal by colon ":".
\begin{lstlisting}
if (currentToken.tokenClass == OPAREN) {
  val expr = parseExpression;

  // functional literal
  if (currentToken.info == COLON
      && expr.isInstanceOf[Identifier]) { ... }
  // expression starting with "("
  else { ... }

}
\end{lstlisting}

\subsection{Analyser}
The question that has to be asked, when implementing functional literals, is what kind of symbol has to be created for them. One way is to convert functional literals to MethodSymbols. This includes to give them a random name like "anonfunc", but also to add an additional constructor to the MethodSymbol, which indicates the parent context. This parent context points to function, where the functional literal is declared:
\begin{lstlisting}
methodSymbol = new MethodSymbol("anonfunc",
         classSymbol, Some(parentContext));
\end{lstlisting}
The additional parameter is needed to correctly assign symbols all free variables. Let us for this case consider the following situation:
\begin{lstlisting}
def method1() {
  var x: Int;
  var func1: Unit => Unit;

  func1 = Unit => {
    var func2: Unit => Unit;\neq

    func2 = Unit => {
      x=x+1
    }
  }
}
\end{lstlisting}
x is clearly a free variable for func2 (as well as for func1), since it is declared outside of the scope of func2 (and func1). In order to attach the proper symbol to each appearance of the variable x, the analyser has to check not only if the variable has been declared in the current functional literal (which is func2) or the parent function (which is func1), but all functions in the tree structure of all parent context. In the previous example, we would also have to check if x is declared in the scope of method1. In case we would not find the declaration of x in method1 (contrary to the previous example), an error is generated, since method1 has no parent context and the declaration of x has not been found in the parent context tree structure.

\subsection{Type Checker}

A more difficult part in the type checker is when a function literal is invoked.

\begin{lstlisting}
case FuncCall(function, expressions) =>
  val funType = tcExpr(function, anyFunction)
      .asInstanceOf[TFunction]
          
  for((expected, localExpr)
      <- funType.inputTypes.zip(expressions)) {
    tcExpr(localExpr, expected);
  }
          
  funType.outputType
\end{lstlisting}

\begin{enumerate}
\item First the expression before the brackets with the function's parameters is verified to be a function (line 2). If func is for example a functional literal, that is defined as Unit=\textgreater(Unit=\textgreater Int). That means it returns another functional literal. One can invoke the nested function by writing func()(). The resulting type Unit=\textgreater(Unit=\textgreater Int) is then saved into funType.
\item The types of the variables given as parameters to the function are then verified to agree with the parameter types given from funType (line 5)
\item Finally the actual return type is compared with the return type of funType (line 10)
\end{enumerate}


Another important aspect is function isSubTypeOf to identify, if a Type is subtype of another type:

\begin{lstlisting}
// regular type (inputTypes...) => outputType
case class TFunction(inputTypes: List[Type],
      outputType: Type) extends Type {
  override def isSubTypeOf(tpe: Type): Boolean =
    tpe match {
      case TAny => true
      case `anyFunction` => true
      case TFunction(iTs, oT) => 
        iTs.size == inputTypes.size && 
        oT.isSubTypeOf(outputType) && 
    	!(for((original, candidate) <- inputTypes.zip(iTs))
          yield { candidate.isSubTypeOf(original) })
            .contains(false)
    		  	
      case _ => false
    }
\end{lstlisting}

\subsection{Lifter}
At last, we do the main work of lamda-lifting, creating closures.
\begin{enumerate}
\item \emph{(All previous steps, typechecking)}
\item Tag variables and members that are used inside functions as "to be boxed"
\item Create boxed classes for every needed boxing types
\item Replace all tagged occurences by boxed objects : declarations, assignations, usages
\item Create closure class from inline function declaration content
\item Replace inline function declaration by an initialization of the newly declared closure class
\item Replace function call by a call to the "apply" method on the closure class
\end{enumerate}



