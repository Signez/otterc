\subsection{Theoretical Background}

\subsubsection{Funarg Problem}
"Funarg Problem refers to the difficulty in implementing first-class functions (functions as first-class objects) in implementations with stack-based memory allocation." (Wikipedia "Funarg Problem", Jan 2013) To illustrate this, let us consider y from the previous example. As we already mentioned would y nomally be out of scope at the moment the func1 is invoked (line 30). But since it is used in a first-class function, it becomes a free variable (contrary to bound varaibles) and can still be accessed even if the context of the variable is closed. In order to make this possible we introduce closures, which binds the functional literals to their free variables. One way of implementing this is descriped by the Lambda Lifting. \newline

\subsection{Parser}
Before solving the Funarg problem, however, we first are going to illustrate how other elements of the compiler have been implemented. To start off with the parser, there is one rather difficult case to mention, which includes to distinguish a functional literal from an expression starting with an opening bracket:
\begin{lstlisting}
f = (a: Int, b: Int) => {â€¦} // functional literal
f = (a + b) * c; // expression starting with "("
\end{lstlisting}
It makes it specially difficult since the toolc parser is a LL(1) parser. This means that the parser reads only one token after the other and does not remember passed token. In the previous example, the parser would first read the characters "f=(". At this point he knows, that an expression has to follow. But if the expression is just an identifier ("a" in the example), he does not know yet to distinguish the two cases. Only when reading one more token, he can identify a functional literal by colon ":".
\begin{lstlisting}
if (currentToken.tokenClass == OPAREN) {
  val expr = parseExpression;

  // functional literal
  if (currentToken.info == COLON && expr.isInstanceOf[Identifier]) { ... }
  // expression starting with "("
  else { ... }

}
\end{lstlisting}

\subsection{Analyser}



If you are using theoretical concepts, explain them first in this subsection.
Even if they come from the course (eg. lattices), try to explain the essential
points \emph{in your own words}. Cite any reference work you used like this
\cite{lamport94}. This should convince us that you know the theory behind what
you coded. 

\subsection{Implementation Details}
Describe all non-obvious tricks you used. Tell us what you thought was hard and
why. If it took you time to figure out the solution to a problem, it probably
means it wasn't easy and you should definitely describe the solution in details
here. If you used what you think is a cool algorithm for some problem, tell us.
Do not however spend time describing trivial things (we what a tree traversal
is, for instance). 

After reading this section, we should be convinced that you knew what you were
doing when you wrote your extension, and that you put some extra consideration
for the harder parts.

